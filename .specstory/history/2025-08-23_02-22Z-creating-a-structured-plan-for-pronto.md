<!-- Generated by SpecStory -->

# Creating a structured plan for Pronto (2025-08-23 02:22Z)

_**User**_

Quero ajuda para montar um plan.md structuring the creation of Pronto -Prompts with Purpose, an AI app that helps people build their software ideas

It's very simple, but powerful

It starts with a chatbox textarea, like ChatGPT, with the description of your idea. Examples are: "I want to analyse my Emails and find important ones"

And then there's a button: "Expand"

This will trigger AI GENERATE_OBJECT to, based on that idea, fill an object with an expanded version of that idea, but filling specifc concepts.

This is an example of good plan from I've generated before. We shoudl generate that, but in structured data. I want to provide this for you use as examples in the fields descriptions (the schema we will pass to GENERATE_OBJECT):

<title>Sistema de Pesquisa Eleitoral</title>
<description>Sistema de Pesquisa Eleitoral (Simulador Político)** - Uma aplicação para simular comportamento eleitoral através da criação de perfis demográficos e aplicação de questionários com respostas geradas por IA.
</description>

### Funcionalidades Principais
<Feature>1. **<Title>Gestão de Eleitores</Title>**: <Description>Criar e gerenciar perfis demográficos detalhados </Description> ...2. **Sistema de Questionários**: Criar perguntas com múltiplas opções 3. **Simulação com IA**: Gerar respostas baseadas no perfil do eleitor 4. **Chat Interativo**: Conversar com eleitores virtuais 5. **Análise de Resultados**: Visualizar respostas e padrões ## 🏗️ Arquitetura Deco 

### Estrutura do Projeto
file: { path: string, description: string }

Ex:
sistema-pesquisa-eleitoral/
├── server/                 # MCP Server (Cloudflare Workers + Deco)
│   ├── main.ts            # Entry point principal
│   ├── deco.gen.ts        # Tipos gerados das integrações
│   ├── schema.ts          # Schemas de dados (Drizzle ORM)
│   ├── db.ts              # Configuração do banco
│   ├── tools/             # Ferramentas organizadas por domínio
│   │   ├── index.ts       # Export central
│   │   ├── eleitor.ts     # Gestão de eleitores
│   │   ├── questionario.ts # Gestão de questionários
│   │   ├── simulacao.ts   # Simulações com IA
│   │   └── chat.ts        # Chat com eleitores
│   ├── workflows/         # Workflows complexos
│   │   ├── index.ts       # Export central
│   │   └── simulacao.ts   # Workflow de simulação
│   ├── drizzle/          # Migrações do banco
│   └── wrangler.toml     # Config Cloudflare
└── view/                 # Frontend React + Tailwind
    ├── src/
    │   ├── routes/       # Rotas da aplicação
    │   │   ├── home.tsx  # Dashboard principal
    │   │   ├── eleitores.tsx      # Lista de eleitores
    │   │   ├── eleitor-form.tsx   # Formulário de eleitor
    │   │   ├── questionarios.tsx  # Lista de questionários
    │   │   ├── questionario-form.tsx # Formulário de questionário
    │   │   └── chat.tsx           # Chat com eleitor
    │   ├── components/   # Componentes reutilizáveis
    │   └── lib/         # RPC client e utilitários
    └── package.json

## 🗄️ Modelos de Dados 
Array<Entity{ title: string, schema: DrizzleSchema }>

Ex:
1. Eleitor
typescript
interface Eleitor {
  id: string;
  nome: string;
  perfil: {
    genero: 'masculino' | 'feminino' | 'não-binário' | 'transgênero' | 'agênero' | 'gênero-fluido' | 'prefiro-não-informar';
    idade: number;
    profissao: string;
    salarioMensal: number;
    classeEconomica: 'A' | 'B' | 'C' | 'D' | 'E';
    localizacao: {
      cidade: string;
      bairro?: string;
      rua?: string;
    };
  };
  createdAt: Date;
  updatedAt: Date;
}
### 2. Questionário
typescript
interface Questionario {
  id: string;
  titulo: string;
  descricao?: string;
  perguntas: Pergunta[];
  createdAt: Date;
  updatedAt: Date;
}

## 🛠️ Tools (Ferramentas)

Array<Tool{title: string, description: string inputSchema: ZodSchema, outputSchema: ZodSchema }>

Ex:
### eleitor.ts
typescript
// Ferramentas para gestão de eleitores
export const criarEleitor = createTool(...)
export const listarEleitores = createTool(...)
export const obterEleitor = createTool(...)
export const atualizarEleitor = createTool(...)
export const removerEleitor = createTool(...)
export const buscarEleitoresPorFiltro = createTool(...)
### questionario.ts
typescript
// Ferramentas para gestão de questionários
export const criarQuestionario = createTool(...)
export const listarQuestionarios = createTool(...)
export const obterQuestionario = createTool(...)
export const atualizarQuestionario = createTool(...)
export const removerQuestionario = createTool(...)
export const adicionarPergunta = createTool(...)
export const removerPergunta = createTool(...)
export const adicionarOpcao = createTool(...)
export const removerOpcao = createTool(...)
### simulacao.ts
typescript
// Ferramentas para simulação com IA
export const simularResposta = createTool(...) // Para uma pergunta específica
export const simularQuestionarioCompleto = createTool(...) // Todo o questionário
export const obterJustificativa = createTool(...) // Explicar resposta
export const analisarPadroesResposta = createTool(...) // Análise agregada
### chat.ts
typescript
// Ferramentas para chat com eleitores
export const iniciarChat = createTool(...)
export const enviarMensagem = createTool(...)
export const obterHistoricoChat = createTool(...)
export const finalizarChat = createTool(...)


## 🔄 Workflows 

<Array<Workflow{title: string, description: string, trigger: string}>

simulacao.ts
typescript
// Workflow complexo para executar questionário completo
export const executarSimulacaoCompleta = createWorkflow({
  name: "executar-simulacao-completa",
  steps: {
    // 1. Validar questionário e eleitores
    validarEntradas: createStepFromTool(validarQuestionarioEEleitores),
    
    // 2. Para cada eleitor, simular todas as respostas
    simularRespostas: createStepFromTool(simularTodasRespostas),
    
    // 3. Salvar resultados no banco
    salvarResultados: createStepFromTool(salvarRespostasNoBanco),
    
    // 4. Gerar análise agregada
    gerarAnalise: createStepFromTool(analisarResultados),
    
    // 5. Retornar resultados formatados
    formatarResultados: createStepFromTool(formatarSaida)
  }
});

## 🎨 Interface Frontend ### 

View ####
Array<View{title: string, pathTemplate: string, description: string, layoutExample: SVG }>

EX:
1. Dashboard (home.tsx) - **Rota**: / - **Funcionalidade**: Visão geral do sistema - **Componentes**: - Cards com estatísticas (total de eleitores, questionários, simulações) - Gráficos de resumo - Ações rápidas #### 2. Gestão de Eleitores (eleitores.tsx) - **Rota**: /eleitores - **Funcionalidade**: Lista e gerencia eleitores - **Componentes**: - Tabela de eleitores com filtros - Botão "Adicionar Eleitor" - Ações: editar, remover, chat #### 3. Formulário de Eleitor (eleitor-form.tsx) - **Rota**: /eleitores/novo e /eleitores/:id/editar - **Funcionalidade**: Criar/editar eleitor - **Componentes**: - Form com validação (nome, gênero, idade, etc.) - **Campo de Gênero**: Select/dropdown com opções inclusivas - Campo de localização com autocomplete - Classe econômica automática baseada em salário **Especificações do Campo Gênero**:
typescript
// Opções para o campo gênero
const opcoesGenero = [
  { value: 'masculino', label: 'Masculino' },
  { value: 'feminino', label: 'Feminino' },
  { value: 'não-binário', label: 'Não-binário' },
  { value: 'transgênero', label: 'Transgênero' },
  { value: 'agênero', label: 'Agênero' },
  { value: 'gênero-fluido', label: 'Gênero fluido' },
  { value: 'prefiro-não-informar', label: 'Prefiro não informar' }
];

// Componente sugerido
<SelectField
  name="genero"
  label="Gênero"
  placeholder="Selecione o gênero"
  options={opcoesGenero}
  required
  helpText="Esta informação ajuda a criar um perfil mais preciso para as simulações"
/>
#### 4. Gestão de Questionários (questionarios.tsx) - **Rota**: /questionarios - **Funcionalidade**: Lista e gerencia questionários - **Componentes**: - Cards de questionários - Botão "Criar Questionário" - Ações: editar, executar simulação, remover #### 5. Formulário de Questionário (questionario-form.tsx) - **Rota**: /questionarios/novo e /questionarios/:id/editar - **Funcionalidade**: Criar/editar questionários - **Componentes**: - Editor de título e descrição - Lista dinâmica de perguntas - Editor de opções para cada pergunta - Drag & drop para reordenar #### 6. Execução de Questionário (questionario-execucao.tsx) - **Rota**: /questionarios/:id/executar - **Funcionalidade**: Executar simulação - **Componentes**: - Seleção de eleitores (todos ou filtrados) - Progress bar da execução - Resultados em tempo real - Visualização de respostas por eleitor #### 7. Chat com Eleitor (chat.tsx) - **Rota**: /eleitores/:id/chat - **Funcionalidade**: Conversar com eleitor virtual - **Componentes**: - Interface de chat - Perfil do eleitor na sidebar - Histórico de conversas ### Componentes Reutilizáveis
typescript
// components/eleitor-card.tsx
interface EleitorCardProps {
  eleitor: Eleitor;
  onEdit: (id: string) => void;
  onDelete: (id: string) => void;
  onChat: (id: string) => void;
}

// components/pergunta-editor.tsx
interface PerguntaEditorProps {
  pergunta: Pergunta;
  onChange: (pergunta: Pergunta) => void;
  onRemove: () => void;
}

// components/resultado-simulacao.tsx
interface ResultadoSimulacaoProps {
  questionario: Questionario;
  respostas: Resposta[];
  eleitores: Eleitor[];
}
## 🤖 Integração com IA ### Configuração Necessária
typescript
// deco.gen.ts (gerado automaticamente)
interface DecoEnv {
  AI: {
    GENERATE_OBJECT: (input: {
      prompt: string;
      schema: any;
    }) => Promise<any>;
  };
}
### Prompts para Simulação
typescript
// Função auxiliar para pronomes inclusivos
const obterPronome = (genero: string) => {
  const pronomes = {
    'masculino': 'um homem',
    'feminino': 'uma mulher',
    'não-binário': 'uma pessoa não-binária',
    'transgênero': 'uma pessoa transgênero',
    'agênero': 'uma pessoa agênero',
    'gênero-fluido': 'uma pessoa de gênero fluido',
    'prefiro-não-informar': 'uma pessoa'
  };
  return pronomes[genero] || 'uma pessoa';
};

const criarPromptResposta = (eleitor: Eleitor, pergunta: Pergunta) => `
Você é ${eleitor.nome}, ${obterPronome(eleitor.perfil.genero)} de ${eleitor.perfil.idade} anos,
${eleitor.perfil.profissao}, que ganha R$ ${eleitor.perfil.salarioMensal} por mês,
classe ${eleitor.perfil.classeEconomica}, morando em ${eleitor.perfil.localizacao.cidade}.

Responda a seguinte pergunta como essa pessoa responderia:
"${pergunta.titulo}"

Opções disponíveis:
${pergunta.opcoes.map((opcao, i) => `${i + 1}. ${opcao}`).join('\n')}

Retorne sua resposta no formato:
{
  "opcao": "texto da opção escolhida",
  "justificativa": "explicação detalhada do por que essa pessoa escolheria essa opção"
}
`;
## 🗃️ Estrutura do Banco de Dados ### Schema Drizzle
typescript
// server/schema.ts
export const eleitores = sqliteTable('eleitores', {
  id: text('id').primaryKey(),
  nome: text('nome').notNull(),
  genero: text('genero', { enum: ['masculino', 'feminino', 'não-binário', 'transgênero', 'agênero', 'gênero-fluido', 'prefiro-não-informar'] }).notNull(),
  idade: integer('idade').notNull(),
  profissao: text('profissao').notNull(),
  salarioMensal: real('salario_mensal').notNull(),
  classeEconomica: text('classe_economica', { enum: ['A', 'B', 'C', 'D', 'E'] }).notNull(),
  cidade: text('cidade').notNull(),
  bairro: text('bairro'),
  rua: text('rua'),
  createdAt: integer('created_at', { mode: 'timestamp' }).notNull().default(sql`CURRENT_TIMESTAMP`),
  updatedAt: integer('updated_at', { mode: 'timestamp' }).notNull().default(sql`CURRENT_TIMESTAMP`),
});

export const questionarios = sqliteTable('questionarios', {
  id: text('id').primaryKey(),
  titulo: text('titulo').notNull(),
  descricao: text('descricao'),
  createdAt: integer('created_at', { mode: 'timestamp' }).notNull().default(sql`CURRENT_TIMESTAMP`),
  updatedAt: integer('updated_at', { mode: 'timestamp' }).notNull().default(sql`CURRENT_TIMESTAMP`),
});

export const perguntas = sqliteTable('perguntas', {
  id: text('id').primaryKey(),
  questionarioId: text('questionario_id').notNull().references(() => questionarios.id),
  titulo: text('titulo').notNull(),
  opcoes: text('opcoes', { mode: 'json' }).$type<string[]>().notNull(),
  ordem: integer('ordem').notNull(),
});

export const respostas = sqliteTable('respostas', {
  id: text('id').primaryKey(),
  eleitorId: text('eleitor_id').notNull().references(() => eleitores.id),
  perguntaId: text('pergunta_id').notNull().references(() => perguntas.id),
  opcaoEscolhida: text('opcao_escolhida').notNull(),
  justificativa: text('justificativa').notNull(),
  confianca: integer('confianca').notNull(),
  createdAt: integer('created_at', { mode: 'timestamp' }).notNull().default(sql`CURRENT_TIMESTAMP`),
});
## 🚀 Fases de Implementação ### Fase 1: Base Structure (1-2 dias) - [x] Setup inicial do projeto Deco - [ ] Configuração do banco de dados - [ ] Schema e migrações - [ ] Setup básico do frontend ### Fase 2: Gestão de Eleitores (2-3 dias) - [ ] Tools de eleitor (CRUD) - [ ] Interface de listagem - [ ] Formulário de criação/edição - [ ] Validações e filtros ### Fase 3: Sistema de Questionários (2-3 dias) - [ ] Tools de questionário (CRUD) - [ ] Editor de questionários - [ ] Gestão de perguntas e opções - [ ] Interface de listagem ### Fase 4: Simulação com IA (3-4 dias) - [ ] Integração com IA (env.AI.GENERATE_OBJECT) - [ ] Tools de simulação - [ ] Workflow de execução completa - [ ] Interface de execução e resultados ### Fase 5: Chat com Eleitores (2-3 dias) - [ ] Sistema de chat - [ ] Prompts personalizados - [ ] Interface de conversa - [ ] Histórico de mensagens ### Fase 6: Análise e Visualização (2-3 dias) - [ ] Análise agregada de resultados - [ ] Gráficos e estatísticas - [ ] Dashboard principal - [ ] Relatórios exportáveis ### Fase 7: Polimento e Deploy (1-2 dias) - [ ] Testes finais - [ ] Otimizações de performance - [ ] Documentação - [ ] Deploy para produção ## 📝 Tarefas Específicas ### Setup Inicial 1. **Configurar projeto Deco**: npm run configure 2. **Setup banco**: Configurar Cloudflare D1 3. **Migrações**: Criar e executar schema inicial 4. **ENV vars**: Configurar integrações de IA ### Desenvolvimento Backend 1. **Schema completo**: Definir todas as tabelas 2. **Tools básicas**: CRUD para cada entidade 3. **Validações**: Input validation em todas as tools 4. **Workflows**: Simulação complexa 5. **Testes**: Tools e workflows ### Desenvolvimento Frontend 1. **Routing**: Setup TanStack Router 2. **RPC Client**: Tipagem automática 3. **Componentes base**: Forms, tables, cards 4. **Páginas principais**: Todas as rotas listadas 5. **Estado global**: Context/store se necessário ### Integração IA 1. **Prompts**: Desenvolver prompts eficazes 2. **Schemas**: Definir retornos estruturados 3. **Error handling**: Tratamento de falhas da IA 4. **Caching**: Cache de respostas similares ## 🔧 Configurações Necessárias ### Environment Variables
env



[vars]
ENVIRONMENT = "production"

## 📊 Métricas de Sucesso

Array<string>

### Funcionais - [ ] CRUD completo de eleitores - [ ] CRUD completo de questionários - [ ] Simulação funcional com IA - [ ] Chat interativo funcionando - [ ] Interface responsiva e intuitiva ### Técnicas - [ ] Tempo de resposta < 2s para simulações - [ ] Precisão das respostas IA > 80% - [ ] Cobertura de testes > 80% - [ ] Performance frontend (Lighthouse > 90) ### UX/UI - [ ] Interface intuitiva e fácil de usar - [ ] Feedback visual adequado - [ ] Tratamento de erros amigável - [ ] Loading states apropriados

Also, add Tools from Other Apps, a list similar of the app's own tools, but this will be which tools we will use from deco marketplace (similar to those we have available at @deco.gen.ts). Ex: Gmail, Discord, Github, WhatsApp. Tools reflect API calls, or adding webhooks...

Think well on how to not lose the important information I mentioned you

One important thing; after the user has generated the structured data for their app, it comes a very important part: the editing

We need to display that structured data in the best way as possible. The tools we show a nicely rendered list

WITH AND AI AGENT TO EACH SECTION to allow edits. This can be a button that will open a modal with a textbox and can make edits for that specific part of the app, using AI_GENERATE_OBJECT to return the newly update version with the user's input

The Routes we show a card with a SVG rendering of the app's layout example

In the bottom, there are an Evals section where, if a user clicks on a button, we evaluate the app's prompt in several scales like: "Avoid ambiguity, Interesting, Potential for 2025 AI Market and other you see fit.

In the end, there's an export prompt which will copy a textual version of the jSON. Just string concatenation

Start studying and writing the document for us to plan this system. This will be used for you to implement it later

---

_**Assistant**_

I'll help you create a comprehensive plan for **Pronto - Prompts with Purpose**, an AI-powered app idea expansion tool. Let me structure this as a detailed planning document.

---



---

I've created a comprehensive planning document for **Pronto - Prompts with Purpose**. The plan covers all the key aspects you mentioned:

## Key Features Included:

1. **Core Flow**: Simple textarea input → AI expansion → Interactive editing → Evaluation → Export
2. **Structured Data Schema**: Comprehensive schema for `AI_GENERATE_OBJECT` that captures all aspects of a software project
3. **Interactive Editing**: AI-powered section editing with modals for each part of the expanded idea
4. **External Tools Integration**: System to suggest tools from the Deco marketplace (Gmail, Discord, GitHub, etc.)
5. **Visual Route Cards**: SVG rendering of app layout examples for each route
6. **Evaluation System**: Multi-criteria assessment (ambiguity avoidance, market potential, technical feasibility, etc.)
7. **Export Functionality**: Convert structured data back to textual prompts

## Architecture Highlights:

- **Domain-organized tools** following the 300-line file limit rule
- **Comprehensive data models** for ideas, evaluations, and exports
- **AI integration schemas** with detailed examples and descriptions
- **Progressive enhancement** from simple input to complex structured output
- **Deco-specific patterns** throughout the implementation

## Implementation Strategy:

The plan includes 7 phases spanning 23-29 days, starting with core infrastructure and building up to advanced features like SVG generation and analytics.

The document is structured to serve as both a technical specification and a development roadmap, with clear success metrics and technical considerations for performance, security, and user experience.

Would you like me to elaborate on any specific section or make adjustments to the plan?

---

